<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>HttpCilent(一) - Hexoqzf</title><meta description="HttpCilent 超文本传输协议（HTTP）是当今Internet上使用的最重要的协议之一。尽管java.net包提供了通过HTTP访问资源的基本功能，但它并未提供许多应用程序所需的完全灵活性或功能。HttpClient提供了一个高效，且功能丰富的包。"><meta property="og:type" content="article"><meta property="og:title" content="HttpCilent(一)"><meta property="og:url" content="http://yoursite.com/2018/09/27/java/httpclient/HttpClient%EF%BC%88%E4%B8%80%EF%BC%89/"><meta property="og:site_name" content="辣椒の酱"><meta property="og:description" content="HttpCilent 超文本传输协议（HTTP）是当今Internet上使用的最重要的协议之一。尽管java.net包提供了通过HTTP访问资源的基本功能，但它并未提供许多应用程序所需的完全灵活性或功能。HttpClient提供了一个高效，且功能丰富的包。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/avatar.jpg"><meta property="article:published_time" content="2018-09-26T16:00:00.000Z"><meta property="article:modified_time" content="2018-10-19T03:19:53.000Z"><meta property="article:author" content="qzf"><meta property="article:tag" content="HttpClient"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/avatar.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://yoursite.com/2018/09/27/java/httpclient/HttpClient%EF%BC%88%E4%B8%80%EF%BC%89/"},"headline":"HttpCilent(一)","image":["https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/avatar.jpg"],"datePublished":"2018-09-26T16:00:00.000Z","dateModified":"2018-10-19T03:19:53.000Z","author":{"@type":"Person","name":"qzf"},"description":"HttpCilent 超文本传输协议（HTTP）是当今Internet上使用的最重要的协议之一。尽管java.net包提供了通过HTTP访问资源的基本功能，但它并未提供许多应用程序所需的完全灵活性或功能。HttpClient提供了一个高效，且功能丰富的包。"}</script><link rel="alternative" href="/atom.xml" title="Hexoqzf" type="application/atom+xml"><link rel="icon" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/wico.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-dark.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/css/style.css"><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/globalUtils.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/live2d/waifu.css"><script type="text/javascript" async src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/live2d/autoload.js"></script></head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191121122803.png" alt="Hexoqzf" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/media">影音</a><a class="navbar-item" href="/album">相册</a><a class="navbar-item" href="/friend">友链</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/myqzf"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2018-09-26T16:00:00.000Z">2018-09-27</time><a class="commentCountImg" href="/2018/09/27/java/httpclient/HttpClient%EF%BC%88%E4%B8%80%EF%BC%89/#comment-container"><span class="display-none-class">a71d4af3076d7e7211c149322ef8ebba</span><img class="not-gallery-item" src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/img/chat.svg"> <span class="commentCount" id="a71d4af3076d7e7211c149322ef8ebba"> 99+</span>    </a><span class="level-item"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Java/">Java</a></span><span class="level-item">36 minutes read (About 5355 words)</span><span class="level-item" id="busuanzi_container_page_pv"><i class="far fa-eye"></i>&nbsp;&nbsp;<span id="busuanzi_value_page_pv">0</span> visits</span></div></div><h1 class="title is-3 is-size-4-mobile">HttpCilent(一)</h1><div class="content"><p>HttpCilent</p>
<p>超文本传输协议（HTTP）是当今Internet上使用的最重要的协议之一。尽管java.net包提供了通过HTTP访问资源的基本功能，但它并未提供许多应用程序所需的完全灵活性或功能。HttpClient提供了一个高效，且功能丰富的包。</p>
<a id="more"></a>

<h3 id="请求执行"><a href="#请求执行" class="headerlink" title="请求执行"></a>请求执行</h3><h4 id="http请求"><a href="#http请求" class="headerlink" title="http请求"></a>http请求</h4><p>HttpClient的支持了在HTTP/1.1规范中定义的所有HTTP方法：<code>GET</code>，<code>HEAD</code>， <code>POST</code>，<code>PUT</code>，<code>DELETE</code>， <code>TRACE</code>和<code>OPTIONS</code>。每个方法类型对应一个特定的类<code>HttpGet</code>， <code>HttpHead</code>，<code>HttpPost</code>， <code>HttpPut</code>，<code>HttpDelete</code>， <code>HttpTrace</code>，和<code>HttpOptions</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(</span><br><span class="line">     <span class="string">"http://www.google.com/search?hl=en&amp;q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq="</span>);</span><br></pre></td></tr></table></figure>

<p>HttpClient提供了<code>URIBuilder</code>实用程序类来简化请求URI的创建和修改。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">URI uri = <span class="keyword">new</span> URIBuilder()</span><br><span class="line">        .setScheme(<span class="string">"http"</span>)</span><br><span class="line">        .setHost(<span class="string">"www.google.com"</span>)</span><br><span class="line">        .setPath(<span class="string">"/search"</span>)</span><br><span class="line">        .setParameter(<span class="string">"q"</span>, <span class="string">"httpclient"</span>)</span><br><span class="line">        .setParameter(<span class="string">"btnG"</span>, <span class="string">"Google Search"</span>)</span><br><span class="line">        .setParameter(<span class="string">"aq"</span>, <span class="string">"f"</span>)</span><br><span class="line">        .setParameter(<span class="string">"oq"</span>, <span class="string">""</span>)</span><br><span class="line">        .build();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(uri);</span><br><span class="line">System.out.println(httpget.getURI());</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://www.google.com/search?q=httpclient&amp;btnG=Google+Search&amp;aq=f&amp;oq=</span><br></pre></td></tr></table></figure>



<h4 id="HTTP响应"><a href="#HTTP响应" class="headerlink" title="HTTP响应"></a>HTTP响应</h4><p>HTTP响应是服务器在接收并解释请求消息后发送回客户端的消息。该消息的第一行包括协议版本，后跟数字状态代码及其相关的文本短语。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response = <span class="keyword">new</span> BasicHttpResponse(HttpVersion.HTTP_1_1, </span><br><span class="line">HttpStatus.SC_OK, <span class="string">"OK"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(response.getProtocolVersion());</span><br><span class="line">System.out.println(response.getStatusLine().getStatusCode());</span><br><span class="line">System.out.println(response.getStatusLine().getReasonPhrase());</span><br><span class="line">System.out.println(response.getStatusLine().toString());</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1</span><br><span class="line">200</span><br><span class="line">OK</span><br><span class="line">HTTP/1.1 200 OK</span><br></pre></td></tr></table></figure>



<h4 id="HTTP-message-headers"><a href="#HTTP-message-headers" class="headerlink" title="HTTP message headers"></a>HTTP message headers</h4><p>HTTP消息可以包含许多描述消息属性的标题，例如内容长度，内容类型等。HttpClient提供了检索，添加，删除和枚举标头的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response = <span class="keyword">new</span> BasicHttpResponse(HttpVersion.HTTP_1_1, </span><br><span class="line">    HttpStatus.SC_OK, <span class="string">"OK"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, </span><br><span class="line">    <span class="string">"c1=a; path=/; domain=localhost"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, </span><br><span class="line">    <span class="string">"c2=b; path=\"/\", c3=c; domain=\"localhost\""</span>);</span><br><span class="line">Header h1 = response.getFirstHeader(<span class="string">"Set-Cookie"</span>);</span><br><span class="line">System.out.println(h1);</span><br><span class="line">Header h2 = response.getLastHeader(<span class="string">"Set-Cookie"</span>);</span><br><span class="line">System.out.println(h2);</span><br><span class="line">Header[] hs = response.getHeaders(<span class="string">"Set-Cookie"</span>);</span><br><span class="line">System.out.println(hs.length);</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: c1=a; path=/; domain=localhost</span><br><span class="line">Set-Cookie: c2=b; path="/", c3=c; domain="localhost"</span><br><span class="line">2</span><br></pre></td></tr></table></figure>

<p>获取给定类型的所有标头的最有效方法是使用<code>HeaderIterator</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response = <span class="keyword">new</span> BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, <span class="string">"OK"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"c1=a; path=/; domain=localhost"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"c2=b; path=\"/\", c3=c; domain=\"localhost\""</span>);</span><br><span class="line"></span><br><span class="line">HeaderIterator it = response.headerIterator(<span class="string">"Set-Cookie"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: c1=a; path=/; domain=localhost</span><br><span class="line">Set-Cookie: c2=b; path="/", c3=c; domain="localhost"</span><br></pre></td></tr></table></figure>

<p><code>HeaderIterator</code>还提供了将HTTP消息解析为单个头元素的便捷方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HttpResponse response = <span class="keyword">new</span> BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, <span class="string">"OK"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"c1=a; path=/; domain=localhost"</span>);</span><br><span class="line">response.addHeader(<span class="string">"Set-Cookie"</span>, <span class="string">"c2=b; path=\"/\", c3=c; domain=\"localhost\""</span>);</span><br><span class="line"></span><br><span class="line">HeaderElementIterator it = <span class="keyword">new</span> BasicHeaderElementIterator(</span><br><span class="line">    response.headerIterator(<span class="string">"Set-Cookie"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">    HeaderElement elem = it.nextElement(); </span><br><span class="line">    System.out.println(elem.getName() + <span class="string">" = "</span> + elem.getValue());</span><br><span class="line">    NameValuePair[] params = elem.getParameters();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</span><br><span class="line">        System.out.println(<span class="string">" "</span> + params[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c1 &#x3D; a</span><br><span class="line">path&#x3D;&#x2F;</span><br><span class="line">domain&#x3D;localhost</span><br><span class="line">c2 &#x3D; b</span><br><span class="line">path&#x3D;&#x2F;</span><br><span class="line">c3 &#x3D; c</span><br><span class="line">domain&#x3D;localhost</span><br></pre></td></tr></table></figure>

<h4 id="HTTP-entity"><a href="#HTTP-entity" class="headerlink" title="HTTP entity"></a>HTTP entity</h4><p>HTTP消息可以携带与请求或响应相关联的内容实体。实体可以在某些请求和某些响应中找到，因为它们是可选的。使用实体的请求称为包含实体的请求。HTTP规范定义了两个封闭请求方法的实体：<code>POST</code>和 <code>PUT</code>。通常http响应会包含一个内容实体。当然也有例外的情况，如应对 <code>HEAD</code>方法<code>204 No Content</code>， <code>304 Not Modified</code>，<code>205 Reset Content</code> 响应。</p>
<p>HttpClient根据来源的不同，划分了三种不同的Http实体内容。</p>
<ul>
<li><strong>streamed:</strong> 内容从流中接收，或在运行中生成，包括从HTTP响应接收的实体。streamed实体通常不可重复。</li>
<li><strong>self-contained:</strong> 内容在内存中或通过独立于连接或其他实体的方式获得。自包含实体通常是可重复的。这种类型的实体主要是封装HTTP请求的实体。</li>
<li><strong>wrapping:</strong>  内容从另一个实体获得。</li>
</ul>
<h5 id="可重复的实体"><a href="#可重复的实体" class="headerlink" title="可重复的实体"></a>可重复的实体</h5><p>实体可以是可重复的，这意味着其内容可以被多次读取。这仅适用于自包含的实体（如 <code>ByteArrayEntity</code>或 <code>StringEntity</code>）。</p>
<h5 id="使用HTTP实体"><a href="#使用HTTP实体" class="headerlink" title="使用HTTP实体"></a>使用HTTP实体</h5><p>如果要从Http实体中读取内容，我们可以利用HttpEntity类的getContent方法来获取实体的输入流（java.io.InputStream)，或者利用HttpEntity类的writeTo(OutputStream)方法来获取输出流，这个方法会把所有的内容写入到给定的流中。</p>
<p>取Content-Type和Content-Length两个头消息（如果有的话）。由于Content-Type包含mime-types的字符编码，比如text/plain或者text/html,HttpEntity类的getContentEncoding()方法就是读取这个编码的。如果头信息不存在，getContentLength（）会返回-1,getContentType()会返回NULL。如果Content-Type信息存在，就会返回一个Header类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">StringEntity myEntity = <span class="keyword">new</span> StringEntity(<span class="string">"important message"</span>, </span><br><span class="line">   ContentType.create(<span class="string">"text/plain"</span>, <span class="string">"UTF-8"</span>));</span><br><span class="line"></span><br><span class="line">System.out.println(myEntity.getContentType());</span><br><span class="line">System.out.println(myEntity.getContentLength());</span><br><span class="line">System.out.println(EntityUtils.toString(myEntity));</span><br><span class="line">System.out.println(EntityUtils.toByteArray(myEntity).length);</span><br></pre></td></tr></table></figure>

<p>stdout &gt;</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/plain; charset=utf-8</span><br><span class="line">17</span><br><span class="line">important message</span><br><span class="line">17</span><br></pre></td></tr></table></figure>

<h4 id="确保底层的资源连接被释放"><a href="#确保底层的资源连接被释放" class="headerlink" title="确保底层的资源连接被释放"></a>确保底层的资源连接被释放</h4><p>为了确保正确释放系统资源，必须关闭与实体关联的内容流或响应本身.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost/"</span>);</span><br><span class="line">CloseableHttpResponse response = httpclient.execute(httpget);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpEntity entity = response.getEntity();</span><br><span class="line">    <span class="keyword">if</span>(entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputStream instream = entity.getContent();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//do something useful</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            instream.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    response.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关闭内容流和关闭响应之间的区别在于前者将尝试通过使用实体内容来保持底层连接处于活动状态，而后者立即关闭并丢弃连接。</p>
<h4 id="使用实体内容"><a href="#使用实体内容" class="headerlink" title="使用实体内容"></a>使用实体内容</h4><p>HttpClient推荐使用HttpEntity的<code>getConent()</code>方法或者HttpEntity的<code>writeTo(OutputStream)</code>方法来消耗掉Http实体内容。HttpClient也提供了<code>EntityUtils</code>这个类，这个类提供一些静态方法可以更容易地读取Http实体的内容和信息。和以java.io.InputStream流读取内容的方式相比，EntityUtils提供的方法可以以字符串或者字节数组的形式读取Http实体。但是，强烈不推荐使用EntityUtils这个类，除非目标服务器发出的响应是可信任的，并且http响应实体的长度不会过大。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost/"</span>);</span><br><span class="line">CloseableHttpResponse response = httpclient.execute(httpget);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpEntity entity = response.getEntity();</span><br><span class="line">    <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">long</span> len = entity.getContentLength();</span><br><span class="line">        <span class="keyword">if</span> (len != -<span class="number">1</span> &amp;&amp; len &lt; <span class="number">2048</span>) &#123;</span><br><span class="line">            System.out.println(EntityUtils.toString(entity));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// Stream content out </span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    response.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在某些情况下，可能需要能够多次读取实体内容。在这种情况下，实体内容必须以某种方式缓冲，无论是在内存中还是在磁盘上。实现这一目标的最简单方法是将原始实体与<code>BufferedHttpEntity</code>类包装在一起。这将导致原始实体的内容被读入内存缓冲区。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpResponse response = &lt;...&gt; </span><br><span class="line">HttpEntity entity = response.getEntity（）; </span><br><span class="line"><span class="keyword">if</span>（entity！= <span class="keyword">null</span>）&#123; </span><br><span class="line">    entity = <span class="keyword">new</span> BufferedHttpEntity（entity）; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="创建HTTP实体内容"><a href="#创建HTTP实体内容" class="headerlink" title="创建HTTP实体内容"></a>创建HTTP实体内容</h4><p>HttpClient提供了几个最常见的数据的容器类，这些类可以通过http连接高效地输出Http实体内容。如字符串，字节数组，输入流，和文件：<code>StringEntity</code>， <code>ByteArrayEntity</code>， <code>InputStreamEntity</code>，和 <code>FileEntity</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">File file = <span class="keyword">new</span> File(<span class="string">"somefile.txt"</span>);</span><br><span class="line">FileEntity entity = <span class="keyword">new</span> FileEntity(file, ContentType.create(<span class="string">"text/plain"</span>, Consts.UTF_8));</span><br><span class="line">HttpPost httppost = <span class="keyword">new</span> HttpPost(<span class="string">"http://localhost/action.do"</span>);</span><br><span class="line">httppost.setEntity(entity);</span><br></pre></td></tr></table></figure>

<p>注意 :<code>InputStreamEntity</code>不可重复，因为它只能从基础数据流中读取一次。建议，实通过继承HttpEntity这个自包含的类来自定义HttpEntity类，而不是直接使用InputStreamEntity这个类。FileEntity就是一个很好的起点（FileEntity就是继承的HttpEntity）。</p>
<h5 id="HTML表单"><a href="#HTML表单" class="headerlink" title="HTML表单"></a>HTML表单</h5><p>许多应用程序需要模拟提交HTML表单的过程，例如，登录到Web应用程序或提交输入数据。HttpClient提供实体类 <code>UrlEncodedFormEntity</code>来实现该过程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">List&lt;NameValuePair&gt; formparams = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">formparams.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"param1"</span>, <span class="string">"value1"</span>));</span><br><span class="line">formparams.add(<span class="keyword">new</span> BasicNameValuePair(<span class="string">"param2"</span>, <span class="string">"value2"</span>));</span><br><span class="line">UrlEncodedFormEntity entity = <span class="keyword">new</span> UrlEncodedFormEntity(formparams, Consts.UTF_8);</span><br><span class="line">HttpPost httppost = <span class="keyword">new</span> HttpPost(<span class="string">"http://localhost/handler.do"</span>);</span><br><span class="line">httppost.setEntity(entity);</span><br></pre></td></tr></table></figure>

<p>该<code>UrlEncodedFormEntity</code>实例将使用所谓的URL编码来编码参数并生成以下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">param1&#x3D;value1&amp;param2&#x3D;value2</span><br></pre></td></tr></table></figure>

<h5 id="内容分块"><a href="#内容分块" class="headerlink" title="内容分块"></a>内容分块</h5><p>一般来说，推荐让HttpClient自己根据Http消息传递的特征来选择最合适的传输编码。当然，如果非要手动控制也是可以的，可以通过设置HttpEntity的setChunked()为true。请注意：HttpClient仅会将这个参数看成是一个建议。如果Http的版本（如http 1.0)不支持内容分块，那么这个参数就会被忽略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">StringEntity entity = <span class="keyword">new</span> StringEntity(<span class="string">"important message"</span>, ContentType.create(<span class="string">"text/plain"</span>, Consts.UTF_8));</span><br><span class="line">entity.setChunked(<span class="keyword">true</span>);</span><br><span class="line">HttpPost httppost = <span class="keyword">new</span> HttpPost(<span class="string">"http://localhost/action.do"</span>);</span><br><span class="line">httppost.setEntity(entity);</span><br></pre></td></tr></table></figure>

<h4 id="响应处理"><a href="#响应处理" class="headerlink" title="响应处理"></a>响应处理</h4><p>最方便的处理http响应的方法就是使用ResponseHandler接口，这个接口中有handleResponse(HttpResponse response)方法。使用这个方法，用户完全不用关心http连接管理器。当使用ResponseHandler时，HttpClient会自动地将Http连接释放给Http管理器，即使http请求失败了或者抛出了异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost/json"</span>);</span><br><span class="line"></span><br><span class="line">ResponseHandler&lt;MyJsonObject&gt; rh = <span class="keyword">new</span> ResponseHandler&lt;MyJsonObject&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> JsonObject <span class="title">handleResponse</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">final</span> HttpResponse response)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        StatusLine statusLine = response.getStatusLine();</span><br><span class="line">        HttpEntity entity = response.getEntity();</span><br><span class="line">        <span class="keyword">if</span> (statusLine.getStatusCode() &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpResponseException(</span><br><span class="line">                    statusLine.getStatusCode(),</span><br><span class="line">                    statusLine.getReasonPhrase());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (entity == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClientProtocolException(<span class="string">"Response contains no content"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Gson gson = <span class="keyword">new</span> GsonBuilder().create();</span><br><span class="line">        ContentType contentType = ContentType.getOrDefault(entity);</span><br><span class="line">        Charset charset = contentType.getCharset();</span><br><span class="line">        Reader reader = <span class="keyword">new</span> InputStreamReader(entity.getContent(), charset);</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(reader, MyJsonObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设置responseHandler，当执行http方法时，就会返回MyJsonObject对象。</span></span><br><span class="line">MyJsonObject myjson = client.execute(httpget, rh);</span><br></pre></td></tr></table></figure>



<h3 id="HttpClient-接口"><a href="#HttpClient-接口" class="headerlink" title="HttpClient 接口"></a>HttpClient 接口</h3><p>对于Http请求执行过程来说，<code>HttpClient</code>的接口有着必不可少的作用。<code>HttpClient</code>接口没有对Http请求的过程做特别的限制和详细的规定，连接管理、状态管理、授权信息和重定向处理这些功能都单独实现。这样用户就可以更简单地拓展接口的功能（比如缓存响应内容）。</p>
<p>一般说来，HttpClient实际上就是一系列特殊的handler或者说策略接口的实现，这些handler负责处理Http协议的某一方面，比如重定向、认证处理、有关连接持久性和keep alive持续时间的决策。这样就允许用户使用自定义的参数来代替默认配置，实现个性化的功能。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ConnectionKeepAliveStrategy keepAliveStrat = <span class="keyword">new</span> DefaultConnectionKeepAliveStrategy() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getKeepAliveDuration</span><span class="params">(HttpResponse response, HttpContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> keepAlive = <span class="keyword">super</span>.getKeepAliveDuration(response, context);</span><br><span class="line">        <span class="keyword">if</span>(keepAlive == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//如果服务器没有设置keep-alive这个参数，我们就把它设置成5秒</span></span><br><span class="line">            keepAlive = <span class="number">5000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> keepAlive;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义httpclient</span></span><br><span class="line">CloseableHttpClient httpclient = HttpClients.custom().setKeepAliveStrategy(keepAliveStrat).build();</span><br></pre></td></tr></table></figure>



<h4 id="HttpClient线程安全性"><a href="#HttpClient线程安全性" class="headerlink" title="HttpClient线程安全性"></a>HttpClient线程安全性</h4><p><code>HttpClient</code>已经实现了线程安全。所以建议在实例化HttpClient后，可以重用于多个请求使用。</p>
<h4 id="HttpClient资源释放"><a href="#HttpClient资源释放" class="headerlink" title="HttpClient资源释放"></a>HttpClient资源释放</h4><p>当一个CloseableHttpClient的实例不再被使用，并且它的作用范围即将失效，和它相关的连接必须被关闭，关闭方法可以调用CloseableHttpClient的close()方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    &lt;...&gt;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    httpclient.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-Http执行上下文"><a href="#1-3-Http执行上下文" class="headerlink" title="1.3 Http执行上下文"></a>1.3 Http执行上下文</h3><p>最初，HTTP被设计为无状态，面向响应请求的协议。但是，现实世界的应用程序通常需要能够通过几个逻辑上相关的请求 - 响应交换来持久保存状态信息。为了使应用程序能够维持处理状态，HttpClient允许在特定的执行上下文中执行HTTP请求，称为HTTP上下文。如果在连续请求之间重用相同的上下文，则多个逻辑相关的请求可以参与逻辑会话。HTTP上下文就和一个java.util.Map&lt;String, Object&gt;功能类似。它实际上就是一个任意命名的值的集合。应用程序可以在Http请求执行前填充上下文的值，也可以在请求执行完毕后检查上下文。</p>
<p><code>HttpContext</code>可以包含任意对象，因此在多个线程之间共享可能不安全。建议每个执行线程维护自己的上下文。</p>
<p>在Http请求执行的过程中，HttpClient会自动添加下面的属性到Http上下文中：</p>
<ul>
<li><p><code>HttpConnection</code> 表示客户端与服务器之间的连接。</p>
</li>
<li><p><code>HttpHost</code> 表示连接目标的实例。</p>
</li>
<li><p><code>HttpRoute</code> 表示全部的连接路由。</p>
</li>
<li><p><code>HttpRequest</code>表示实际HTTP请求的实例。在执行上下文中，最终的HttpRequest对象会代表http消息的状态。Http/1.0和Http/1.1都默认使用相对的uri。但是如果使用了非隧道模式的代理服务器，就会使用绝对路径的uri。</p>
</li>
<li><p><code>HttpResponse</code> 表示实际HTTP响应的实例。</p>
</li>
<li><p><code>java.lang.Boolean</code> 表示是否请求被成功的发送给目标服务器。</p>
</li>
<li><p><code>RequestConfig</code> 表示http request的配置信息。</p>
</li>
<li><p><code>java.util.List&lt;URI&gt;</code> 表示Http响应中的所有重定向地址。</p>
</li>
</ul>
<p>可以使用<code>HttpClientContext</code>适配器类来简化与上下文状态的交互。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpContext context = &lt;...&gt;</span><br><span class="line">HttpClientContext clientContext = HttpClientContext.adapt(context);</span><br><span class="line">HttpHost target = clientContext.getTargetHost();</span><br><span class="line">HttpRequest request = clientContext.getRequest();</span><br><span class="line">HttpResponse response = clientContext.getResponse();</span><br><span class="line">RequestConfig config = clientContext.getRequestConfig();</span><br></pre></td></tr></table></figure>

<p>同一个逻辑会话中的多个Http请求，应该使用相同的Http上下文来执行，这样就可以自动地在http请求中传递会话上下文和状态信息。 </p>
<p>在下面的例子中，我们在开头设置的参数，会被保存在上下文中，并且会应用到后续的http请求中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">RequestConfig requestConfig = RequestConfig.custom()</span><br><span class="line">        .setSocketTimeout(<span class="number">1000</span>)</span><br><span class="line">        .setConnectTimeout(<span class="number">1000</span>)</span><br><span class="line">        .build();</span><br><span class="line"></span><br><span class="line">HttpGet httpget1 = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost/1"</span>);</span><br><span class="line">httpget1.setConfig(requestConfig);</span><br><span class="line">CloseableHttpResponse response1 = httpclient.execute(httpget1, context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpEntity entity1 = response1.getEntity();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    response1.close();</span><br><span class="line">&#125;</span><br><span class="line">HttpGet httpget2 = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost/2"</span>);</span><br><span class="line">CloseableHttpResponse response2 = httpclient.execute(httpget2, context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpEntity entity2 = response2.getEntity();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    response2.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Http-协议拦截器"><a href="#Http-协议拦截器" class="headerlink" title="Http 协议拦截器"></a>Http 协议拦截器</h4><p>HTTP协议拦截器是一种实现一个特定的方面的HTTP协议的代码程序。通常情况下，协议拦截器会将一个或多个头消息加入到接受或者发送的消息中。协议拦截器也可以操作消息的内容实体—消息内容的压缩/解压缩就是个很好的例子。通常，这是通过使用“装饰”开发模式，一个包装实体类用于装饰原来的实体来实现。一个拦截器可以合并，形成一个逻辑单元。</p>
<p>协议拦截器可以通过共享信息协作——比如处理状态——通过HTTP执行上下文。协议拦截器可以使用Http上下文存储一个或者多个连续请求的处理状态。</p>
<p>通常，只要拦截器不依赖于一个特定状态的http上下文，那么拦截执行的顺序就无所谓。如果协议拦截器有相互依赖关系，必须以特定的顺序执行，那么它们应该按照特定的顺序加入到协议处理器中。</p>
<p>协议处理器必须是线程安全的。类似于servlets，协议拦截器不应该使用变量实体，除非访问这些变量是同步的（线程安全的）。</p>
<p>下面是个例子，讲述了本地的上下文时如何在连续请求中记录处理状态的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.custom().addInterceptorLast(<span class="keyword">new</span> HttpRequestInterceptor() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(HttpRequest request, HttpContext context)</span> <span class="keyword">throws</span> HttpException, IOException </span>&#123;</span><br><span class="line">        AtomicInteger count = (AtomicInteger)context.getAttribute(<span class="string">"count"</span>);</span><br><span class="line">        request.addHeader(<span class="string">"Count"</span>, Integer.toString(count.getAndIncrement()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).build();</span><br><span class="line"></span><br><span class="line">AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">HttpClientContext localContext = HttpClientContext.create();</span><br><span class="line">localContext.setAttribute(<span class="string">"count"</span>, count);</span><br><span class="line"></span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost"</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="number">10</span>; i++) &#123;</span><br><span class="line">    CloseableHttpResponse response = httpclient.execute(httpget, localContext);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        HttpEntity entity = response.getEntity();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        response.close();</span><br><span class="line">    &#125;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码在发送http请求时，会自动添加Count这个header，可以使用wireshark抓包查看。</p>
<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>HttpClient会被抛出两种类型的异常，一种是java.io.IOException，当遇到I/O异常时抛出（socket超时，或者socket被重置）;另一种是HttpException,表示Http失败，如Http协议使用不正确。通常认为，I/O错误时不致命、可修复的，而Http协议错误是致命了，不能自动修复的错误。注意，<code>HttpClient</code>实现重新抛出<code>HttpException</code> 如<code>ClientProtocolException</code>，它是<code>java.io.IOException</code>的子类。这使程序能够从单个catch子句处理I / O错误和协议违规。</p>
<h5 id="HTTP传输安全"><a href="#HTTP传输安全" class="headerlink" title="HTTP传输安全"></a>HTTP传输安全</h5><p>Http协议不能满足所有类型的应用程序，HTTP是一种简单的面向请求/响应的协议，最初设计用于支持静态或动态生成的内容检索。它从未打算支持事务操作。例如，如果HTTP服务器成功接收和处理请求，生成响应并将状态代码发送回客户端，这个过程是Http协议应该保证的。如果客户端由于读取超时，请求取消或系统崩溃而未能完全接收响应，则服务器将不会尝试回滚事务。如果客户端决定重试相同的请求，则服务器将不可避免地多次执行同一事务。在某些情况下，这可能会导致应用程序数据损坏或应用程序状态不一致。</p>
<p>尽管HTTP从未被设计为支持事务处理，但如果满足某些条件，它仍可用作关键任务应用程序的传输协议。为确保HTTP传输层安全，系统必须确保应用层上HTTP方法的幂等性。</p>
<h5 id="方法的幂等性"><a href="#方法的幂等性" class="headerlink" title="方法的幂等性"></a>方法的幂等性</h5><p>应用程序需要正确地处理同一方法多次执行造成的影响。例如，这可以通过提供唯一的事务id和通过避免执行相同逻辑操作的其他手段来实现。</p>
<p>注意：这个问题不只是HttpClient才会有，基于浏览器的应用程序也会遇到Http方法不幂等的问题。</p>
<p>HttpClient默认把非实体方法get、head方法看做幂等方法，把实体方法post、put方法看做非幂等方法。</p>
<h5 id="异常自动修复"><a href="#异常自动修复" class="headerlink" title="异常自动修复"></a>异常自动修复</h5><p>默认情况下，HttpClient会尝试自动修复I/O异常。默认的自动恢复机制仅限于一些已知安全的异常情况。</p>
<ul>
<li>HttpClient不会尝试修复任何逻辑或者http协议错误（即从HttpException衍生出来的异常）。</li>
<li>HttpClient将自动重试那些被认为是幂等的方法。</li>
<li>会自动再次发送遇到transport异常的方法，前提是Http请求仍旧保持着连接（即请求尚未完全传输到服务器），HttpClient将自动重试那些因传输异常而失败的方法。</li>
</ul>
<h5 id="请求重试HANDLER"><a href="#请求重试HANDLER" class="headerlink" title="请求重试HANDLER"></a>请求重试HANDLER</h5><p>如果要自定义异常处理机制，我们需要实现<code>HttpRequestRetryHandler</code>接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">HttpRequestRetryHandler retryHandler = <span class="keyword">new</span> HttpRequestRetryHandler() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retryRequest</span><span class="params">(IOException exception, <span class="keyword">int</span> executionCount, HttpContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(executionCount &gt;= <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">//超过最大重试次数</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> InterruptedIOException) &#123;</span><br><span class="line">            <span class="comment">//超时</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> UnknownHostException) &#123;</span><br><span class="line">            <span class="comment">//目标服务不可达</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> ConnectTimeoutException) &#123;</span><br><span class="line">            <span class="comment">//连接被拒绝</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(exception <span class="keyword">instanceof</span> SSLException) &#123;</span><br><span class="line">            <span class="comment">//ssl握手异常</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HttpClientContext clientContext = HttpClientContext.adapt(context);</span><br><span class="line">        HttpRequest request = clientContext.getRequest();</span><br><span class="line">        <span class="keyword">boolean</span> idempotent = !(request <span class="keyword">instanceof</span> HttpEntityEnclosingRequest); </span><br><span class="line">        <span class="keyword">if</span>(idempotent) &#123;</span><br><span class="line">            <span class="comment">//如果请求时幂等的，就再次尝试</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br><span class="line">CloseableHttpClient httpclient = HttpClients.custom()</span><br><span class="line">    .setRetryHandler(retryHandler)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>

<h4 id="终止请求"><a href="#终止请求" class="headerlink" title="终止请求"></a>终止请求</h4><p>在某些情况下，由于目标服务器上的高负载或客户端上发出的并发请求太多，HTTP请求执行无法在预期的时间范围内完成。在这种情况下，可能需要提前终止请求并取消阻止在I / O操作中阻塞的执行线程。可以在执行的任何阶段通过调用<code>HttpUriRequest#abort()</code>方法中止由HttpClient执行的HTTP请求 。此方法是线程安全的，可以从任何线程调用。当HTTP请求中止时，其执行线程 - 即使当前在I / O操作中被阻塞 - 也可以通过抛出一个<code>InterruptedIOException</code>来解除阻塞 ，释放资源。</p>
<h4 id="重定向处理"><a href="#重定向处理" class="headerlink" title="重定向处理"></a>重定向处理</h4><p>HttpClient会自动处理所有类型的重定向，除了那些Http规范明确禁止的重定向。<code>See Other</code> (status code 303) redirects on <code>POST</code> and <code>PUT</code> requests are converted to <code>GET</code> requests as required by the HTTP specification. 可以使用自定义的重定向策略来放松Http规范对Post方法重定向的限制。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////LaxRedirectStrategy可以自动重定向所有的HEAD，GET，POST请求，解除了http规范对post请求重定向的限制。</span></span><br><span class="line">LaxRedirectStrategy redirectStrategy = <span class="keyword">new</span> LaxRedirectStrategy();</span><br><span class="line">		CloseableHttpClient httpclient = HttpClients.custom()</span><br><span class="line">				.setRedirectStrategy(redirectStrategy)</span><br><span class="line">				.build();</span><br></pre></td></tr></table></figure>

<p>HttpClient通常必须在执行过程中重写请求消息。默认情况下，HTTP / 1.0和HTTP / 1.1通常使用相对请求URI。同样，原始请求可能会多次从一个位置重定向到另一个位置。可以使用原始请求和上下文构建最终解释的绝对HTTP路径。URIUtils 类的 resolve`方法可用于构建用于生成最终请求的绝对URI。此方法包括重定向请求或原始请求中的最后一个片段标识符。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">CloseableHttpClient httpclient = HttpClients.createDefault();</span><br><span class="line">HttpClientContext context = HttpClientContext.create();</span><br><span class="line">HttpGet httpget = <span class="keyword">new</span> HttpGet(<span class="string">"http://localhost:8080/"</span>);</span><br><span class="line">CloseableHttpResponse response = httpclient.execute(httpget, context);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    HttpHost target = context.getTargetHost();</span><br><span class="line">    List&lt;URI&gt; redirctLocations = context.getRedirectLocations();</span><br><span class="line">    URI location = URIUtils.resolve(httpget.getURI(), target, redirctLocations);</span><br><span class="line">    System.out.println(<span class="string">"Final HTTP location: "</span>+ location.toASCIIString());</span><br><span class="line">    <span class="comment">// 一般会取得一个绝对路径的uri</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    response.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考：<a href="http://hc.apache.org/httpcomponents-client-4.5.x/">http://hc.apache.org/httpcomponents-client-4.5.x/</a></p>
<pre><code>https://www.yeetrack.com/?p=773</code></pre></div><div class="article-tags size-small is-uppercase mb-4"><i class="fas fa-tags has-text-grey"></i> <a class="link-muted mr-2" rel="tag" href="/tags/HttpClient/">HttpClient</a><p class="text-right font1_1"><time datetime="2018-10-19T03:19:53.000Z"><strong><em> 本文最后修改于: 2018-10-19.</em></strong></time></p></div><ul class="post-copyright"><li><strong>本文标题：</strong><a href="http://yoursite.com/2018/09/27/java/httpclient/HttpClient（一）/">HttpCilent(一)</a></li><li><strong>本文作者：</strong><a href="http://yoursite.com">qzf</a></li><li><strong>本文链接：</strong><a href="http://yoursite.com/2018/09/27/java/httpclient/HttpClient（一）/">http://yoursite.com/2018/09/27/java/httpclient/HttpClient（一）/</a></li><li><strong>版权声明：</strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明出处！</li></ul><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 推荐文章</span><br></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><div class="social-share"></div><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button is-info donate"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135456.png" alt="Alipay"></span></a><a class="button is-success donate"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="https://raw.githubusercontent.com/removeif/blog_image/master/img/2019/20190802135550.png" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/09/28/%E5%B7%A5%E4%BD%9C/Windows%E6%9F%A5%E7%9C%8B%E7%AB%AF%E5%8F%A3%E5%8D%A0%E7%94%A8%E8%BF%9B%E7%A8%8B/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Windows查看端口占用进程</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/09/25/%E5%B7%A5%E4%BD%9C/%E9%98%BF%E9%87%8C%E4%BA%91SLB%E8%AF%81%E4%B9%A6/"><span class="level-item">阿里云SLB证书</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.6.0/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: 'a71d4af3076d7e7211c149322ef8ebba',
            repo: 'blog_comment',
            owner: 'removeif',
            clientID: '46a9f3481b46ea0129d8',
            clientSecret: '79c7c9cb847e141757d7864453bcbf89f0655b24',
            admin: ["removeif"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><!--!--><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="is-rounded" src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@latest/img/avatar.jpg" alt="辣椒の酱"></figure><p class="title is-size-4 is-block line-height-inherit">辣椒の酱</p><p class="is-size-6 is-block">尚未执佩剑，转眼即江湖</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>阿尔及利亚</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">276</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">43</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">93</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://weibo.com/u/3050419984" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/myqzf"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Weibo" href="https://weibo.com/u/3050419984"><i class="fab fa-weibo"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:qzf98763@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="Next" href="https://removeif.github.io/remove.io"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-white is-marginless" target="_blank" rel="noopener" title="RSS" href="/atom.xml"><i class="fas fa-rss"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟延迟...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-05-22T16:00:00.000Z">2020-05-23</time></p><p class="title is-6"><a class="link-muted" href="/2020/05/23/Jenkins/%E5%89%8D%E7%AB%AF%E6%96%87%E4%BB%B6%E6%9B%B4%E6%96%B0%E6%96%B9%E6%A1%88/">前端文件更新方案</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/Jenkins/">Jenkins</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-28T16:00:00.000Z">2020-04-29</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/29/nginx/echo-nginx-module%E6%A8%A1%E5%9D%97/">echo-nginx-module模块</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-27T16:00:00.000Z">2020-04-28</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/28/nginx/%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/nginx%E5%9C%A8%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84%E4%B8%AD%E4%BF%AE%E6%94%B9%E5%AD%97%E7%AC%A6%E4%B8%B2/">nginx在请求路径中修改字符串</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/nginx/">nginx</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-19T16:00:00.000Z">2020-04-20</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/20/%E5%B7%A5%E4%BD%9C/java%E6%9C%8D%E5%8A%A1CPU%E5%8D%A0%E7%94%A8%E9%AB%98/">java服务CPU占用高</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-04-18T16:00:00.000Z">2020-04-19</time></p><p class="title is-6"><a class="link-muted" href="/2020/04/19/%E5%B7%A5%E4%BD%9C/java%E6%9C%8D%E5%8A%A1%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%AE%9A%E4%BD%8D/">java服务内存占用定位</a></p><p class="is-uppercase"><i class="fas fa-folder-open has-text-grey"> </i><a class="link-muted" href="/categories/%E5%B7%A5%E4%BD%9C/">工作</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Elasticsearch/"><span class="level-start"><span class="level-item">Elasticsearch</span></span><span class="level-end"><span class="level-item tag">21</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/HTTPS/"><span class="level-start"><span class="level-item">HTTPS</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Java基础</span></span><span class="level-end"><span class="level-item tag">15</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Jenkins/"><span class="level-start"><span class="level-item">Jenkins</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">7</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/MongoDB/"><span class="level-start"><span class="level-item">MongoDB</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/OCR/"><span class="level-start"><span class="level-item">OCR</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/RabbitMq/"><span class="level-start"><span class="level-item">RabbitMq</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Spring-boot/"><span class="level-start"><span class="level-item">Spring-boot</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/04/"><span class="level-start"><span class="level-item">April 2020</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Elasticsearch/"><span class="tag">Elasticsearch</span><span class="tag is-grey-lightest">21</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E/"><span class="tag">搜索引擎</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/IO%E6%B5%81/"><span class="tag">IO流</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux/"><span class="tag">linux</span><span class="tag is-grey-lightest">15</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%B7%A5%E4%BD%9C/"><span class="tag">工作</span><span class="tag is-grey-lightest">14</span></a></div><div class="control"><a class="tags has-addons" href="/tags/MongoDB/"><span class="tag">MongoDB</span><span class="tag is-grey-lightest">13</span></a></div><div class="control"><a class="tags has-addons" href="/tags/20%E5%A4%A9/"><span class="tag">20天</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%9B%86%E5%90%88/"><span class="tag">集合</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/java/"><span class="tag">java</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mongodb/"><span class="tag">mongodb</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/21%E5%A4%A9/"><span class="tag">21天</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Spring-boot/"><span class="tag">Spring-boot</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Jenkins/"><span class="tag">Jenkins</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux/"><span class="tag">Linux</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/json/"><span class="tag">json</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/redis/"><span class="tag">redis</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/rsync/"><span class="tag">rsync</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4/"><span class="tag">命令</span><span class="tag is-grey-lightest">5</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=removeifFeedsId&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="removeifFeedsId" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div><p class="help">输入邮箱开始订阅，更博后邮件通知！</p></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://cdn.jsdelivr.net/gh/removeif/blog_image/img/2019/20191121122803.png" alt="Hexoqzf" height="28"></a><p class="size-small"><span>&copy; 2020 qzf</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a>,Modify by <a href="https://github.com/removeif" target="_blank">removeif</a> <br>© 版权说明：[本网站所有内容均收集于互联网或自己创作,<br>    方便于网友与自己学习交流，如有侵权，请<a href="/message" target="_blank">留言</a>，立即处理]<br><script type="text/javascript" src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/statistics.js"></script><span id="statistic-times">网站运行时间统计加载中...</span><br><div class="size-small"><span id="busuanzi_container_site_uv">❤️感谢<strong> <span id="busuanzi_value_site_uv">99+</span> </strong></span>小伙伴的<strong> <span id="busuanzi_value_site_pv">99+</span> </strong>次光临，查看💐<a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">主题源码</a>！❤️</div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/myqzf"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'http://yoursite.com',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/back-to-top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/gallery.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/main.js" defer></script><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/comment-issue-data.js" defer></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/css/insight.css"><div class="searchbox ins-search"><div class="searchbox-container ins-search-container"><div class="searchbox-input-wrapper"><input class="searchbox-input ins-search-input" type="text" placeholder="Type something..."><span class="searchbox-close ins-close ins-selectable"><i class="fa fa-times-circle"></i></span></div><div class="searchbox-result-wrapper ins-section-wrapper"><div class="ins-section-container"></div></div></div></div><script>(function (window) {
            var INSIGHT_CONFIG = {
                TRANSLATION: {
                    POSTS: 'Posts',
                    PAGES: 'Pages',
                    CATEGORIES: 'Categories',
                    TAGS: 'Tags',
                    UNTITLED: '(Untitled)',
                },
                CONTENT_URL: 'https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/content.json',
            };
            window.INSIGHT_CONFIG = INSIGHT_CONFIG;
        })(window);</script><script src="https://cdn.jsdelivr.net/gh/removeif/removeif.github.io@v2.2.1/js/insight.js" defer></script></body></html>